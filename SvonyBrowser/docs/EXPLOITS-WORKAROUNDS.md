# üîì Evony Reverse Engineering - Exploits & Workarounds

**Version:** 1.0  
**Last Updated:** 2025-01-12  
**Status:** For Educational/Research Purposes Only

---

## ‚ö†Ô∏è Disclaimer

This documentation is provided for **educational and research purposes only**. The techniques described are for understanding the Evony protocol and improving bot detection/security research.

---

## üîç Known Vulnerabilities

### 1. Weak Password Hashing

**Issue:** MD5 used for password hashing without salt
```python
# Vulnerable pattern
password_hash = md5(password).hexdigest()
login_request = {"username": username, "password": password_hash}
```

**Failsafe:** Implement client-side pre-hashing
```python
# Add your own salt before sending
salted_password = md5(password + custom_salt).hexdigest()
```

### 2. Predictable Session Tokens

**Issue:** Session tokens follow predictable patterns
```python
# Token structure (reconstructed)
token = f"{player_id}_{server_id}_{timestamp}_{md5(signature)}"
```

**Workaround:** Token prediction for session recovery
```python
def predict_token(player_id, server_id):
    timestamp = int(time.time())
    signature = md5(f"{player_id}{server_id}{timestamp}evony_salt").hexdigest()
    return f"{player_id}_{server_id}_{timestamp}_{signature[:16]}"
```

### 3. Rate Limiting Bypass

**Issue:** Rate limits based on IP, not session
```python
# Rotation workaround
proxies = ['proxy1:8080', 'proxy2:8080', 'proxy3:8080']
current_proxy = 0

def get_next_proxy():
    global current_proxy
    proxy = proxies[current_proxy]
    current_proxy = (current_proxy + 1) % len(proxies)
    return proxy
```

### 4. Timing Attack on Actions

**Issue:** Server validates action timing client-side
```python
# Add random delays to mimic human behavior
import random

def human_delay():
    base_delay = 0.5
    variance = random.uniform(0, 0.3)
    return base_delay + variance

time.sleep(human_delay())
```

---

## üõ°Ô∏è Detection Evasion Techniques

### 1. User-Agent Rotation

```python
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15"
]

def get_headers():
    return {
        "User-Agent": random.choice(USER_AGENTS),
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9",
        "Accept-Language": "en-US,en;q=0.9",
        "Connection": "keep-alive"
    }
```

### 2. Request Timing Patterns

```python
# Mimic human clicking patterns
class HumanBehavior:
    def __init__(self):
        self.last_action = time.time()
        self.action_count = 0
    
    def wait_before_action(self):
        # Humans take 1-3 seconds between actions
        min_wait = 1.0
        max_wait = 3.0
        
        # Longer pauses every 10 actions (like checking something)
        if self.action_count % 10 == 0:
            min_wait = 5.0
            max_wait = 15.0
        
        wait_time = random.uniform(min_wait, max_wait)
        time.sleep(wait_time)
        
        self.last_action = time.time()
        self.action_count += 1
```

### 3. Proxy Header Removal (Fiddler)

```csharp
// From EvonyRE-CustomRules.cs
if (m_StealthMode)
{
    oS.oRequest.headers.Remove("Via");
    oS.oRequest.headers.Remove("X-Forwarded-For");
    oS.oRequest.headers.Remove("X-Forwarded-Host");
    oS.oRequest.headers.Remove("X-Forwarded-Proto");
    oS.oRequest.headers.Remove("Proxy-Connection");
    oS.oRequest.headers.Remove("X-ProxyUser-IP");
    oS.oRequest["Connection"] = "keep-alive";
}
```

---

## üîß Protocol Manipulation

### 1. Packet Injection Template

```python
import struct

class AMF3Packet:
    def __init__(self):
        self.data = bytearray()
    
    def add_header(self, msg_type, seq_id, flags=0):
        # Header: Length(4) + Type(1) + SeqID(4) + Flags(1)
        self.msg_type = msg_type
        self.seq_id = seq_id
        self.flags = flags
    
    def add_string(self, value):
        # AMF3 string encoding
        self.data.append(0x06)  # String marker
        encoded = value.encode('utf-8')
        self.write_u29(len(encoded) << 1 | 1)
        self.data.extend(encoded)
    
    def add_integer(self, value):
        # AMF3 integer encoding
        self.data.append(0x04)  # Integer marker
        self.write_u29(value)
    
    def write_u29(self, value):
        if value < 0x80:
            self.data.append(value)
        elif value < 0x4000:
            self.data.append((value >> 7) | 0x80)
            self.data.append(value & 0x7F)
        elif value < 0x200000:
            self.data.append((value >> 14) | 0x80)
            self.data.append((value >> 7) | 0x80)
            self.data.append(value & 0x7F)
        else:
            self.data.append((value >> 22) | 0x80)
            self.data.append((value >> 15) | 0x80)
            self.data.append((value >> 8) | 0x80)
            self.data.append(value & 0xFF)
    
    def build(self):
        header = struct.pack('>IBIB', 
            len(self.data) + 10,  # Total length
            self.msg_type,
            self.seq_id,
            self.flags
        )
        return header + bytes(self.data)
```

### 2. Action Spoofing

```python
# Spoof different action types
def create_action_packet(action, params):
    packet = AMF3Packet()
    packet.add_header(msg_type=1, seq_id=get_next_seq())
    
    # Action format: category.action
    packet.add_string(action)  # e.g., "hero.hireHero"
    
    # Add parameters based on action
    for key, value in params.items():
        packet.add_string(key)
        if isinstance(value, int):
            packet.add_integer(value)
        else:
            packet.add_string(str(value))
    
    return packet.build()

# Example: Hire hero
hire_packet = create_action_packet("hero.hireHero", {
    "castleId": 12345,
    "heroName": "Napoleon"
})
```

### 3. Response Interception

```python
# Intercept and modify server responses
class ResponseInterceptor:
    def __init__(self):
        self.handlers = {}
    
    def register_handler(self, action_pattern, handler):
        self.handlers[action_pattern] = handler
    
    def intercept(self, response_bytes):
        decoded = self.decode_amf3(response_bytes)
        action = decoded.get('action', '')
        
        for pattern, handler in self.handlers.items():
            if pattern in action:
                modified = handler(decoded)
                return self.encode_amf3(modified)
        
        return response_bytes

# Example: Modify resource response
def boost_resources(response):
    if 'resources' in response['data']:
        for res in response['data']['resources']:
            res['amount'] *= 2  # Double resources (visual only)
    return response

interceptor = ResponseInterceptor()
interceptor.register_handler('resource', boost_resources)
```

---

## üöÄ Automation Failsafes

### 1. Connection Recovery

```python
class ConnectionManager:
    def __init__(self, max_retries=3, backoff_factor=2):
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
        self.connection = None
        self.retry_count = 0
    
    def connect(self):
        while self.retry_count < self.max_retries:
            try:
                self.connection = self._establish_connection()
                self.retry_count = 0
                return True
            except Exception as e:
                self.retry_count += 1
                wait_time = self.backoff_factor ** self.retry_count
                print(f"Connection failed, retry {self.retry_count}/{self.max_retries} in {wait_time}s")
                time.sleep(wait_time)
        
        return False
    
    def send_with_retry(self, packet):
        for attempt in range(self.max_retries):
            try:
                if not self.connection:
                    self.connect()
                
                response = self.connection.send(packet)
                return response
            except ConnectionError:
                self.connection = None
                time.sleep(self.backoff_factor ** attempt)
        
        raise Exception("Max retries exceeded")
```

### 2. Session Keepalive

```python
import threading

class SessionKeepalive:
    def __init__(self, interval=300):  # 5 minutes
        self.interval = interval
        self.running = False
        self.thread = None
    
    def start(self, connection):
        self.connection = connection
        self.running = True
        self.thread = threading.Thread(target=self._keepalive_loop)
        self.thread.daemon = True
        self.thread.start()
    
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join()
    
    def _keepalive_loop(self):
        while self.running:
            try:
                # Send heartbeat packet
                self.connection.send(self._create_heartbeat())
                time.sleep(self.interval)
            except Exception as e:
                print(f"Keepalive failed: {e}")
                self.running = False
    
    def _create_heartbeat(self):
        # Minimal packet to keep session alive
        return create_action_packet("system.heartbeat", {})
```

### 3. Anti-Ban Measures

```python
class AntiBanSystem:
    def __init__(self):
        self.action_history = []
        self.max_actions_per_minute = 20
        self.suspicious_patterns = []
    
    def can_perform_action(self):
        now = time.time()
        
        # Clean old actions (older than 1 minute)
        self.action_history = [t for t in self.action_history if now - t < 60]
        
        # Check rate limit
        if len(self.action_history) >= self.max_actions_per_minute:
            wait_time = 60 - (now - self.action_history[0])
            print(f"Rate limit reached, waiting {wait_time:.1f}s")
            time.sleep(wait_time)
        
        self.action_history.append(now)
        return True
    
    def add_human_variance(self):
        # Random micro-pauses
        if random.random() < 0.1:  # 10% chance
            time.sleep(random.uniform(0.1, 0.5))
        
        # Occasional longer pause
        if random.random() < 0.02:  # 2% chance
            pause = random.uniform(5, 30)
            print(f"Taking a break for {pause:.1f}s")
            time.sleep(pause)
```

---

## üìù Script Templates

### NPC Farming Script

```actionscript
// AutoEvony NPC farming template
label npcFarm
set npcLevel 5
set maxMarches 4

// Find NPCs
scanmap %c.coord% 50
set npcList $c.getMapFieldList(npc, %npcLevel%, 50, c.castle.fieldId)$

// Send marches
set marchCount 0
label sendMarch
ifgoto {%marchCount%>=%maxMarches%} waitReturn

// Get next available army
set army $c.cm.localArmies[%marchCount%]$
iferror $%army%.armyId$ goto waitReturn

// Get next NPC target
set target $%npcList%[%marchCount%]$
iferror $%target%.fieldId$ goto waitReturn

// Send attack
set response $c.af.getArmyCommands().sendArmy(%army%.armyId, %target%.x, %target%.y, 1)$
gosub waitResp %response% 10

set marchCount {%marchCount%+1}
goto sendMarch

label waitReturn
sleep 60
goto npcFarm
```

### Resource Collection Script

```actionscript
// Collect all resources
label collectResources

// Loop through all cities
set cityIndex 0
label nextCity
iferror $c.allCities[%cityIndex%]$ goto done

set currentCastle $c.allCities[%cityIndex%].castle$

// Collect from each resource building
set posId 2001
label nextBuilding
ifgoto {%posId%>2040} incrementCity

set building $%currentCastle%.getBuildingByPosition(%posId%)$
iferror $%building%.typeId$ goto skipBuilding

// Check if resource building (type 20-23)
ifgoto {{%building%.typeId<20}||{%building%.typeId>23}} skipBuilding

// Collect
set resp $c.af.getCastleCommands().collectResource(%currentCastle%.id, %posId%)$
gosub waitResp %resp% 5

label skipBuilding
set posId {%posId%+1}
goto nextBuilding

label incrementCity
set cityIndex {%cityIndex%+1}
goto nextCity

label done
echo "Resource collection complete"
sleep 300
goto collectResources
```

---

## üîó Network Tools

### Named Pipe Client (C#)

```csharp
using System.IO.Pipes;

public class FiddlerPipeClient
{
    private NamedPipeClientStream _pipe;
    private StreamReader _reader;
    
    public void Connect()
    {
        _pipe = new NamedPipeClientStream(".", "SvonyFiddlerTraffic", 
            PipeDirection.In, PipeOptions.Asynchronous);
        _pipe.Connect(5000);
        _reader = new StreamReader(_pipe);
    }
    
    public async Task<string> ReadPacketAsync()
    {
        return await _reader.ReadLineAsync();
    }
    
    public void Disconnect()
    {
        _reader?.Dispose();
        _pipe?.Dispose();
    }
}
```

### WebSocket Tunnel

```python
import asyncio
import websockets

async def tunnel_to_websocket(pipe_path, ws_url):
    """Forward named pipe traffic to WebSocket for remote analysis"""
    
    async with websockets.connect(ws_url) as ws:
        # Open named pipe
        pipe = open(pipe_path, 'r')
        
        while True:
            line = pipe.readline()
            if line:
                await ws.send(line)
            else:
                await asyncio.sleep(0.1)
```

---

## üìö Related Documentation

- [EVONY-PROTOCOLS-EXTENDED.md](./EVONY-PROTOCOLS-EXTENDED.md) - Complete protocol reference
- [FIDDLER-SCRIPTS.md](./FIDDLER-SCRIPTS.md) - Fiddler automation scripts
- [CLI-TOOLS.md](./CLI-TOOLS.md) - Command-line tools
